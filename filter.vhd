-- -------------------------------------------------------------
--
-- Module: filter
-- Generated by MATLAB(R) 9.9 and Filter Design HDL Coder 3.1.8.
-- Generated on: 2021-04-07 13:24:48
-- -------------------------------------------------------------

-- -------------------------------------------------------------
-- HDL Code Generation Options:
--
-- TargetLanguage: VHDL
-- FoldingFactor: 18
-- ClockEnableInputPort: ce
-- TargetDirectory: D:\TonyGit\SysGen
-- TestBenchStimulus: step ramp chirp 

-- Filter Specifications:
--
-- Sample Rate     : N/A (normalized frequency)
-- Response        : Lowpass
-- Specification   : Fp,Fst,Ap,Ast
-- Passband Ripple : 1 dB
-- Passband Edge   : 0.008
-- Stopband Atten. : 80 dB
-- Stopband Edge   : 0.032
-- -------------------------------------------------------------

-- -------------------------------------------------------------
-- HDL Implementation    : Fully Serial
-- Folding Factor        : 18
-- -------------------------------------------------------------
-- Filter Settings:
--
-- Discrete-Time IIR Filter (real)
-- -------------------------------
-- Filter Structure    : Direct-Form II, Second-Order Sections
-- Number of Sections  : 3
-- Stable              : Yes
-- Linear Phase        : No
-- Arithmetic          : fixed
-- Numerator           : u16,15 -> [0 2)
-- Denominator         : u16,15 -> [0 2)
-- Scale Values        : u16,18 -> [0 2.500000e-01)
-- Input               : s16,15 -> [-1 1)
-- Section Input       : s16,14 -> [-2 2)
-- Section Output      : s16,12 -> [-8 8)
-- Output              : s16,12 -> [-8 8)
-- State               : s16,15 -> [-1 1)
-- Numerator Prod      : s32,30 -> [-2 2)
-- Denominator Prod    : s32,30 -> [-2 2)
-- Numerator Accum     : s34,30 -> [-8 8)
-- Denominator Accum   : s34,30 -> [-8 8)
-- Round Mode          : convergent
-- Overflow Mode       : wrap
-- -------------------------------------------------------------



LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.numeric_std.ALL;

ENTITY filter IS
   PORT( clk                             :   IN    std_logic; 
         ce                              :   IN    std_logic; 
         reset                           :   IN    std_logic; 
         filter_in                       :   IN    std_logic_vector(15 DOWNTO 0); -- sfix16_En15
         filter_out                      :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En12
         );

END filter;


----------------------------------------------------------------
--Module Architecture: filter
----------------------------------------------------------------
ARCHITECTURE rtl OF filter IS
  -- Local Functions
  -- Type Definitions
  TYPE delay_pipeline_type IS ARRAY (NATURAL range <>) OF unsigned(15 DOWNTO 0); -- ufix16_En15
  -- Constants
  CONSTANT scaleconst1                    : signed(22 DOWNTO 0) := to_signed(33613, 23); -- sfix23_En18
  CONSTANT coeff_b1_section1              : signed(22 DOWNTO 0) := to_signed(262144, 23); -- sfix23_En18
  CONSTANT coeff_b2_section1              : signed(22 DOWNTO 0) := to_signed(0, 23); -- sfix23_En18
  CONSTANT coeff_b3_section1              : signed(22 DOWNTO 0) := to_signed(262144, 23); -- sfix23_En18
  CONSTANT coeff_a2_section1              : signed(22 DOWNTO 0) := to_signed(0, 23); -- sfix23_En18
  CONSTANT coeff_a3_section1              : signed(22 DOWNTO 0) := to_signed(257448, 23); -- sfix23_En18
  CONSTANT scaleconst2                    : signed(22 DOWNTO 0) := to_signed(18883, 23); -- sfix23_En18
  CONSTANT coeff_b1_section2              : signed(22 DOWNTO 0) := to_signed(262144, 23); -- sfix23_En18
  CONSTANT coeff_b2_section2              : signed(22 DOWNTO 0) := to_signed(0, 23); -- sfix23_En18
  CONSTANT coeff_b3_section2              : signed(22 DOWNTO 0) := to_signed(262144, 23); -- sfix23_En18
  CONSTANT coeff_a2_section2              : signed(22 DOWNTO 0) := to_signed(0, 23); -- sfix23_En18
  CONSTANT coeff_a3_section2              : signed(22 DOWNTO 0) := to_signed(248728, 23); -- sfix23_En18
  CONSTANT scaleconst3                    : signed(22 DOWNTO 0) := to_signed(2758, 23); -- sfix23_En18
  CONSTANT coeff_b1_section3              : signed(22 DOWNTO 0) := to_signed(262144, 23); -- sfix23_En18
  CONSTANT coeff_b2_section3              : signed(22 DOWNTO 0) := to_signed(0, 23); -- sfix23_En18
  CONSTANT coeff_b3_section3              : signed(22 DOWNTO 0) := to_signed(262144, 23); -- sfix23_En18
  CONSTANT coeff_a2_section3              : signed(22 DOWNTO 0) := to_signed(0, 23); -- sfix23_En18
  CONSTANT coeff_a3_section3              : signed(22 DOWNTO 0) := to_signed(242800, 23); -- sfix23_En18
  -- Signals
  SIGNAL input_register                   : signed(15 DOWNTO 0); -- sfix16_En15
  SIGNAL cur_count                        : unsigned(4 DOWNTO 0); -- ufix5
  SIGNAL phase_0                          : std_logic; -- boolean
  SIGNAL phase_2                          : std_logic; -- boolean
  SIGNAL phase_3                          : std_logic; -- boolean
  SIGNAL phase_5                          : std_logic; -- boolean
  SIGNAL phase_6                          : std_logic; -- boolean
  SIGNAL phase_8                          : std_logic; -- boolean
  SIGNAL phase_9                          : std_logic; -- boolean
  SIGNAL phase_11                         : std_logic; -- boolean
  SIGNAL phase_12                         : std_logic; -- boolean
  SIGNAL phase_14                         : std_logic; -- boolean
  SIGNAL phase_15                         : std_logic; -- boolean
  SIGNAL phase_17                         : std_logic; -- boolean
  SIGNAL sectionipconvert                 : signed(15 DOWNTO 0); -- sfix16_En14
  SIGNAL storagetypeconvert               : unsigned(15 DOWNTO 0); -- ufix16_En15
  SIGNAL prev_stg_op1                     : signed(15 DOWNTO 0); -- sfix16_En12
  SIGNAL prev_stg_op2                     : signed(15 DOWNTO 0); -- sfix16_En12
  SIGNAL storage_state_in1                : unsigned(15 DOWNTO 0); -- ufix16_En15
  SIGNAL delay_section1                   : delay_pipeline_type(0 TO 1); -- ufix16_En15
  SIGNAL storage_state_in2                : unsigned(15 DOWNTO 0); -- ufix16_En15
  SIGNAL delay_section2                   : delay_pipeline_type(0 TO 1); -- ufix16_En15
  SIGNAL storage_state_in3                : unsigned(15 DOWNTO 0); -- ufix16_En15
  SIGNAL delay_section3                   : delay_pipeline_type(0 TO 1); -- ufix16_En15
  SIGNAL input_section1_cast              : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL storage_in_section1_cast         : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL delay_section11_cast             : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL delay_section12_cast             : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL input_section2_cast              : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL storage_in_section2_cast         : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL delay_section21_cast             : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL delay_section22_cast             : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL input_section3_cast              : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL storage_in_section3_cast         : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL delay_section31_cast             : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL delay_section32_cast             : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL inputmux_section_1               : signed(18 DOWNTO 0); -- sfix19_En15
  SIGNAL coeffmux_section_1               : signed(22 DOWNTO 0); -- sfix23_En18
  SIGNAL prod                             : signed(41 DOWNTO 0); -- sfix42_En33
  SIGNAL prod_den                         : signed(31 DOWNTO 0); -- sfix32_En30
  SIGNAL prod_den_cast_temp               : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL prod_den_cast                    : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL prod_den_cast_neg                : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL unaryminus_temp                  : signed(34 DOWNTO 0); -- sfix35_En30
  SIGNAL prod_num                         : signed(31 DOWNTO 0); -- sfix32_En30
  SIGNAL prod_num_cast_temp               : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL prod_num_cast                    : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL accum_mux_in1                    : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL accum_mux_in2                    : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL accum_mux_out                    : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL accum_mux_in1_temp               : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL sectionipconvert_cast            : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL final_phase                      : std_logic; -- boolean
  SIGNAL section_phase                    : std_logic; -- boolean
  SIGNAL accum_reg                        : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL add_cast                         : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL add_cast_1                       : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL add_temp                         : signed(34 DOWNTO 0); -- sfix35_En30
  SIGNAL acc_out_cast_numacc              : signed(33 DOWNTO 0); -- sfix34_En30
  SIGNAL sectionopconvert                 : signed(15 DOWNTO 0); -- sfix16_En12
  SIGNAL output_typeconvert               : signed(15 DOWNTO 0); -- sfix16_En12
  SIGNAL output_register                  : signed(15 DOWNTO 0); -- sfix16_En12


BEGIN

  -- Block Statements
  input_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      input_register <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce = '1' THEN
        input_register <= signed(filter_in);
      END IF;
    END IF; 
  END PROCESS input_reg_process;

  Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cur_count <= to_unsigned(0, 5);
    ELSIF clk'event AND clk = '1' THEN
      IF ce = '1' THEN
        IF cur_count >= to_unsigned(17, 5) THEN
          cur_count <= to_unsigned(0, 5);
        ELSE
          cur_count <= cur_count + to_unsigned(1, 5);
        END IF;
      END IF;
    END IF; 
  END PROCESS Counter_process;

  phase_0 <= '1' WHEN cur_count = to_unsigned(0, 5) AND ce = '1' ELSE '0';

  phase_2 <= '1' WHEN cur_count = to_unsigned(2, 5) AND ce = '1' ELSE '0';

  phase_3 <= '1' WHEN cur_count = to_unsigned(3, 5) AND ce = '1' ELSE '0';

  phase_5 <= '1' WHEN cur_count = to_unsigned(5, 5) AND ce = '1' ELSE '0';

  phase_6 <= '1' WHEN cur_count = to_unsigned(6, 5) AND ce = '1' ELSE '0';

  phase_8 <= '1' WHEN cur_count = to_unsigned(8, 5) AND ce = '1' ELSE '0';

  phase_9 <= '1' WHEN cur_count = to_unsigned(9, 5) AND ce = '1' ELSE '0';

  phase_11 <= '1' WHEN cur_count = to_unsigned(11, 5) AND ce = '1' ELSE '0';

  phase_12 <= '1' WHEN cur_count = to_unsigned(12, 5) AND ce = '1' ELSE '0';

  phase_14 <= '1' WHEN cur_count = to_unsigned(14, 5) AND ce = '1' ELSE '0';

  phase_15 <= '1' WHEN cur_count = to_unsigned(15, 5) AND ce = '1' ELSE '0';

  phase_17 <= '1' WHEN cur_count = to_unsigned(17, 5) AND ce = '1' ELSE '0';


  -- Next stage input = Previous stage output. Storing Previous stage output
  prev_stg_op1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      prev_stg_op1 <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_5 = '1' THEN
        prev_stg_op1 <= sectionopconvert;
      END IF;
    END IF; 
  END PROCESS prev_stg_op1_process;

  prev_stg_op2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      prev_stg_op2 <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_11 = '1' THEN
        prev_stg_op2 <= sectionopconvert;
      END IF;
    END IF; 
  END PROCESS prev_stg_op2_process;

  delay_process_section1 : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delay_section1 <= (OTHERS => (OTHERS => '0'));
    ELSIF clk'event AND clk = '1' THEN
      IF phase_0 = '1' THEN
        delay_section1(1) <= delay_section1(0);
        delay_section1(0) <= storage_state_in1;
      END IF;
    END IF;
  END PROCESS delay_process_section1;

  delay_process_section2 : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delay_section2 <= (OTHERS => (OTHERS => '0'));
    ELSIF clk'event AND clk = '1' THEN
      IF phase_0 = '1' THEN
        delay_section2(1) <= delay_section2(0);
        delay_section2(0) <= storage_state_in2;
      END IF;
    END IF;
  END PROCESS delay_process_section2;

  delay_process_section3 : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delay_section3 <= (OTHERS => (OTHERS => '0'));
    ELSIF clk'event AND clk = '1' THEN
      IF phase_0 = '1' THEN
        delay_section3(1) <= delay_section3(0);
        delay_section3(0) <= storage_state_in3;
      END IF;
    END IF;
  END PROCESS delay_process_section3;

  -- Making common precision for input and state 
  input_section1_cast <= resize(input_register, 19);

  delay_section11_cast <= signed(resize(delay_section1(0), 19));

  delay_section12_cast <= signed(resize(delay_section1(1), 19));

  storage_in_section1_cast <= signed(resize(storage_state_in1, 19));

  input_section2_cast <= resize(prev_stg_op1(15 DOWNTO 0) & '0' & '0' & '0', 19);

  delay_section21_cast <= signed(resize(delay_section2(0), 19));

  delay_section22_cast <= signed(resize(delay_section2(1), 19));

  storage_in_section2_cast <= signed(resize(storage_state_in2, 19));

  input_section3_cast <= resize(prev_stg_op2(15 DOWNTO 0) & '0' & '0' & '0', 19);

  delay_section31_cast <= signed(resize(delay_section3(0), 19));

  delay_section32_cast <= signed(resize(delay_section3(1), 19));

  storage_in_section3_cast <= signed(resize(storage_state_in3, 19));

  inputmux_section_1 <= input_section1_cast WHEN ( cur_count = to_unsigned(0, 5) ) ELSE
                             delay_section11_cast WHEN ( cur_count = to_unsigned(1, 5) ) ELSE
                             delay_section12_cast WHEN ( cur_count = to_unsigned(2, 5) ) ELSE
                             storage_in_section1_cast WHEN ( cur_count = to_unsigned(3, 5) ) ELSE
                             delay_section11_cast WHEN ( cur_count = to_unsigned(4, 5) ) ELSE
                             delay_section12_cast WHEN ( cur_count = to_unsigned(5, 5) ) ELSE
                             input_section2_cast WHEN ( cur_count = to_unsigned(6, 5) ) ELSE
                             delay_section21_cast WHEN ( cur_count = to_unsigned(7, 5) ) ELSE
                             delay_section22_cast WHEN ( cur_count = to_unsigned(8, 5) ) ELSE
                             storage_in_section2_cast WHEN ( cur_count = to_unsigned(9, 5) ) ELSE
                             delay_section21_cast WHEN ( cur_count = to_unsigned(10, 5) ) ELSE
                             delay_section22_cast WHEN ( cur_count = to_unsigned(11, 5) ) ELSE
                             input_section3_cast WHEN ( cur_count = to_unsigned(12, 5) ) ELSE
                             delay_section31_cast WHEN ( cur_count = to_unsigned(13, 5) ) ELSE
                             delay_section32_cast WHEN ( cur_count = to_unsigned(14, 5) ) ELSE
                             storage_in_section3_cast WHEN ( cur_count = to_unsigned(15, 5) ) ELSE
                             delay_section31_cast WHEN ( cur_count = to_unsigned(16, 5) ) ELSE
                             delay_section32_cast;

  coeffmux_section_1 <= scaleconst1 WHEN ( cur_count = to_unsigned(0, 5) ) ELSE
                             coeff_a2_section1 WHEN ( cur_count = to_unsigned(1, 5) ) ELSE
                             coeff_a3_section1 WHEN ( cur_count = to_unsigned(2, 5) ) ELSE
                             coeff_b1_section1 WHEN ( cur_count = to_unsigned(3, 5) ) ELSE
                             coeff_b2_section1 WHEN ( cur_count = to_unsigned(4, 5) ) ELSE
                             coeff_b3_section1 WHEN ( cur_count = to_unsigned(5, 5) ) ELSE
                             scaleconst2 WHEN ( cur_count = to_unsigned(6, 5) ) ELSE
                             coeff_a2_section2 WHEN ( cur_count = to_unsigned(7, 5) ) ELSE
                             coeff_a3_section2 WHEN ( cur_count = to_unsigned(8, 5) ) ELSE
                             coeff_b1_section2 WHEN ( cur_count = to_unsigned(9, 5) ) ELSE
                             coeff_b2_section2 WHEN ( cur_count = to_unsigned(10, 5) ) ELSE
                             coeff_b3_section2 WHEN ( cur_count = to_unsigned(11, 5) ) ELSE
                             scaleconst3 WHEN ( cur_count = to_unsigned(12, 5) ) ELSE
                             coeff_a2_section3 WHEN ( cur_count = to_unsigned(13, 5) ) ELSE
                             coeff_a3_section3 WHEN ( cur_count = to_unsigned(14, 5) ) ELSE
                             coeff_b1_section3 WHEN ( cur_count = to_unsigned(15, 5) ) ELSE
                             coeff_b2_section3 WHEN ( cur_count = to_unsigned(16, 5) ) ELSE
                             coeff_b3_section3;

  prod <= inputmux_section_1 * coeffmux_section_1;

  prod_den <= resize(shift_right(prod(34 DOWNTO 0) + ( "0" & (prod(3) & NOT prod(3) & NOT prod(3))), 3), 32);

  prod_den_cast_temp <= resize(prod_den, 34);

  prod_den_cast <= prod_den_cast_temp;

  unaryminus_temp <= ('0' & prod_den_cast) WHEN prod_den_cast = "1000000000000000000000000000000000"
      ELSE -resize(prod_den_cast,35);
  prod_den_cast_neg <= unaryminus_temp(33 DOWNTO 0);

  prod_num <= resize(shift_right(prod(34 DOWNTO 0) + ( "0" & (prod(3) & NOT prod(3) & NOT prod(3))), 3), 32);

  prod_num_cast_temp <= resize(prod_num, 34);

  prod_num_cast <= prod_num_cast_temp;

  accum_mux_in1 <= prod_num_cast WHEN ( cur_count = to_unsigned(0, 5) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(1, 5) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(2, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(3, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(4, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(5, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(6, 5) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(7, 5) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(8, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(9, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(10, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(11, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(12, 5) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(13, 5) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(14, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(15, 5) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(16, 5) ) ELSE
                        prod_num_cast;

  final_phase <=  phase_0 OR phase_3 OR phase_6 OR phase_9 OR phase_12 OR phase_15;

  section_phase <=  phase_0 OR phase_6 OR phase_12;

  accum_mux_in1_temp <= sectionipconvert_cast WHEN ( section_phase = '1' ) ELSE
                             accum_mux_in1;

  accum_mux_out <= accum_mux_in1_temp WHEN ( final_phase = '1' ) ELSE
                        accum_mux_in2;

  accumulator_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      accum_reg <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce = '1' THEN
        accum_reg <= accum_mux_out;
      END IF;
    END IF; 
  END PROCESS accumulator_reg_process;

  add_cast <= accum_reg;
  add_cast_1 <= accum_mux_in1;
  add_temp <= resize(add_cast, 35) + resize(add_cast_1, 35);
  accum_mux_in2 <= add_temp(33 DOWNTO 0);

  storagetypeconvert <= unsigned(resize(shift_right(unsigned(accum_mux_out(30 DOWNTO 0)) + ( "0" & (accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15) & NOT accum_mux_out(15))), 15), 16));

  sectionipconvert <= resize(shift_right(prod(34 DOWNTO 0) + ( "0" & (prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19) & NOT prod(19))), 19), 16);

  sectionipconvert_cast <= resize(sectionipconvert(15 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 34);

  acc_out_cast_numacc <= accum_mux_out;

  sectionopconvert <= resize(shift_right(acc_out_cast_numacc(33 DOWNTO 0) + ( "0" & (acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18))), 18), 16);

  output_typeconvert <= resize(shift_right(acc_out_cast_numacc(33 DOWNTO 0) + ( "0" & (acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18))), 18), 16);

  storage_reg1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      storage_state_in1 <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_2 = '1' THEN
        storage_state_in1 <= storagetypeconvert;
      END IF;
    END IF; 
  END PROCESS storage_reg1_process;

  storage_reg2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      storage_state_in2 <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_8 = '1' THEN
        storage_state_in2 <= storagetypeconvert;
      END IF;
    END IF; 
  END PROCESS storage_reg2_process;

  storage_reg3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      storage_state_in3 <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_14 = '1' THEN
        storage_state_in3 <= storagetypeconvert;
      END IF;
    END IF; 
  END PROCESS storage_reg3_process;

  Output_Register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output_register <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_17 = '1' THEN
        output_register <= output_typeconvert;
      END IF;
    END IF; 
  END PROCESS Output_Register_process;

  -- Assignment Statements
  filter_out <= std_logic_vector(output_register);
END rtl;
